---
title: "Using the ESCTreeResults API"
# subtitle: "v0.5"
execute: 
  enabled: true
title-block-banner: "#491656"
css: styles.css
---

## Outline

This notebook details how to call the ESCTreeResults API endpoint to retrieve tree species suitability metrics for a given set of environmental dose variables.

## Import required packages

::: {.panel-tabset}

## Python

```{python import_packages_py}
import requests
import json
import pandas
pandas.options.mode.chained_assignment = None
```

## R

```{r import_packages_r}
library(httr)
library(jsonlite)
library(dplyr)
```

:::

## Compose API request

Establish API POST request URL

::: {.panel-tabset}

## Python

```{python url_py}
base_url = "http://209.97.132.245:8000/ESCTreeResults/"
```

## R

```{r url_r}
base_url <- "http://209.97.132.245:8000/ESCTreeResults/"
```

:::

Establish the Soil Moisture Regime (SMR) and Soil Nutrient Regime (SNR) manual modifier values, if required. Otherwise set to `NA` (R) or `None` (Python).

* smr:float, any number between 0 and 8. Indicative categorical values are as follows:
    * 1 = Very Wet
    * 2 = Wet 
    * 3 = Moist
    * 4 = Moist
    * 5 = Fresh
    * 6 = Slightly Dry
    * 7 = Moderately Dry
    * 8 = Very Dry
* snr:float, any number between 0 and 6. Indicative categorical values are as follows:
    * 0 = Very Poor (VP1)
    * 0.5 = Very Poor (VP2)
    * 1 = Very Poor (VP3)
    * 1.5 = Very Poor - Poor
    * 2 = Poor
    * 3 = Medium
    * 4 = Rich
    * 5 = Very Rich
    * 6 = Carbonate

::: {.panel-tabset}

## Python

```{python soilOpts_py}
smr_modVal = None
snr_modVal = None
```

## R

```{r soilOpts_r}
smr_modVal <- NA
snr_modVal <- NA
```

:::

Establish the escSiteData dictionary. To do this, a dictionary containing the values can be composed manually be first establishing lists of values.

::: {.panel-tabset}

## Python

```{python otherOpts_py}
climateScen_vals = ["RCP2.6", "RCP2.6"]
climateYear_vals = ["1980_2000", "2060_2080"]
smr_vals = [1, 1]
snr_vals = [2, 2]
at_vals = [1300.0447, 1538.3716]
ct_vals = [6.13745, 6.13745]
dams_vals = [15.321886, 15.321886]
md_vals = [100.896255, 92.44555]
```

## R

```{r otherOpts_r}
climateScen_vals <- list("RCP2.6", "RCP2.6")
climateYear_vals <- list("1980_2000", "2060_2080")
smr_vals <- list(1, 1)
snr_vals <- list(2, 2)
at_vals <- list(1300.0447, 1538.3716)
ct_vals <- list(6.13745, 6.13745)
dams_vals <- list(15.321886, 15.321886)
md_vals <- list(100.896255, 92.44555)
```

:::

Then form the `escSiteData` dictionary:

::: {.panel-tabset}

## Python

```{python formEscSiteData_py}
escSiteData = {'climateScen': climateScen_vals, 'climateYear': climateYear_vals, 
               'SMR': smr_vals, 'SNR': snr_vals, 'AT': at_vals, 
               'CT': ct_vals, 'DAMS': dams_vals, 'MD': md_vals}
```

## R

```{r formEscSiteData_r}
escSiteData = list('climateScen' = climateScen_vals, 'climateYear' = climateYear_vals, 
                   'SMR' = smr_vals, 'SNR' = snr_vals, 'AT' = at_vals, 
                   'CT' = ct_vals, 'DAMS' = dams_vals, 'MD' = md_vals)
```

:::

Alternatively, the response from the `ESCSiteData` API can be passed to escSiteData.

Establish the site modifier options and species group filter.

* drainage:int
    * 0 = None.
    * 1 = Drainage installed.
* brash:int
    * 0 = None (new planting).
    * 1 = Fresh brash (<18 months).
    * 2 = Brash (>18 months).
* fertiliser:int
    * 0 = None.
    * 1 = Fertiliser applied.
* exposure:int
    * 0 = None.
    * 1 = Exposed ridge/Coastal zone.
    * 2 = Local shelter/Less exposed/Underplanting.
* filter:int
    * 0 = No filter
    * 1 = Conifers only
    * 2 = Broadleaves only
    * 3 = Natives only
    * 4 = Non-natives only

::: {.panel-tabset}

## Python

```{python siteMod_py}
drainage = 0
brash = 0
fertiliser = 0
exposure = 0
filter = 0
```

## R

```{r siteMod_r}
drainage <- 0
brash <- 0
fertiliser <- 0
exposure <- 0
filter <- 0
```

:::

Establish the ESC version.

* escVersion:str
    * "4.33" = "4.33"

::: {.panel-tabset}

## Python

```{python escV_py}
escVersion = "4.33"
```

## R

```{r escV_r}
escVersion <- "4.33"
```

:::

Compose the request body.

::: {.panel-tabset}

## Python

```{python reqBody_py}
req_body = {"smr": smr_modVal, "snr": snr_modVal,
            "escSiteData": escSiteData,
            "drainage": drainage, "brash": brash, 
            "fertiliser": fertiliser, "exposure": exposure,
            "filter": filter,
            "escVersion": escVersion}
```

## R

```{r reqBody_r}
req_list <- list("smr" = smr_modVal, "snr" = snr_modVal,
                 "escSiteData" = escSiteData,
                 "drainage" = drainage, "brash" = brash, 
                 "fertiliser" =  fertiliser, "exposure" = exposure, 
                 "filter" = filter,
                 "escVersion" = escVersion)

req_body <- jsonlite::toJSON(req_list, auto_unbox = TRUE)
```

:::


## Make the API call

Call the ESCTreeResults API

::: {.panel-tabset}

## Python

```{python apiCall_py}
ESCTreeResultsresponse = requests.post(url = base_url, json = req_body)
ESCTreeResultsresponse.status_code == 200
```

## R

```{r apiCall_r}
ESCTreeResultsresponse <- httr::POST(url = base_url, body = req_body)
ESCTreeResultsresponse$status_code == 200
```

:::

Establish a function to deserialize the json response into a nested dictionary or nested list.

::: {.panel-tabset}

## Python

```{python deserializeFunc_py}
def deserialize(responseJson:str) -> dict:
    
    loadedJson = json.loads(responseJson)

    for k,v in loadedJson.items():
        for w,s in loadedJson[k].items():
            for t,c in loadedJson[k][w].items():
                loadedJson[k][w][t] = pandas.DataFrame.from_dict(data = json.loads(c))
            
    return loadedJson
```

## R

```{r deserializeFunc_r}
deserialize <- function(responseJson){

    responseContent <- httr::content(responseJson)
    responseContent <- jsonlite::fromJSON(responseContent)

    for(i in names(responseContent)){
        for(j in names(responseContent[[i]])){
            for(k in names(responseContent[[i]][[j]])){
                responseContent[[i]][[j]][[k]] = jsonlite::fromJSON(responseContent[[i]][[j]][[k]])
            }
        }
    }
    return(responseContent)
}
```

:::

Call the `deserializeResults` function on the ESC API output.

::: {.panel-tabset}

## Python

```{python deserialize_py}
ESCTreeResultsresponse_dict = deserialize(responseJson = ESCTreeResultsresponse.json())
```

## R

```{r deserialize_r}
ESCTreeResultsresponse_list <- deserialize(responseJson = ESCTreeResultsresponse)
```

:::


## Explore results

The object produced (`ESCTreeResultsresponse_dict` or `ESCTreeResultsresponse_list`) is a nested dictionary with the following structure:

```
ESCresponse_dict (dict)
├── Metadata (dict)
│   ├── ESCMetadata (dict)
│   │   ├── ESCTreeMetadata (DataFrame)
│   ├── APIMetadata (dict)
│   │   ├── DateTime (DataFrame)
└───RCP2.6 (dict)
│   ├── 1980_2000 (dict)
│   │   ├── ESCDoseVals (DataFrame)
│   │   ├── ESCResponseVals (DataFrame)
│   │   ├── ESCSuitMetrics (DataFrame)
│   ├── 2060_2080 (dict)
│   │   ├── ESCDoseVals (DataFrame)
│   │   ├── ESCResponseVals (DataFrame)
│   │   ├── ESCSuitMetrics (DataFrame)
└───RCP8.5 (dict)
    ├── 1980_2000 (dict)
    │   ├── ESCDoseVals (DataFrame)
    │   ├── ESCResponseVals (DataFrame)
    │   ├── ESCSuitMetrics (DataFrame)
    ├── 2060_2080 (dict)
    │   ├── ESCDoseVals (DataFrame)
    │   ├── ESCResponseVals (DataFrame)
    │   ├── ESCSuitMetrics (DataFrame)
```

Access the ESC data frames from the API response using the following code.

The `ESCDoseVals` data frame contains the environmental dose variables obtained from the modelled data and/or manually entered, which are then modified by the aforementioned API query parameters `drainage`, `brash`, `fertiliser`, and `exposure`.
For more information on the underlying method see the [Forest Research Bulletin 124](https://www.forestresearch.gov.uk/publications/archive-an-ecological-site-classification-for-forestry-in-great-britain/) and the [Forest Research Technical Paper 20](https://www.forestresearch.gov.uk/publications/archive-an-ecological-site-classification-for-forestry-in-great-britain-with-special-reference-to-grampian-scotland/).
Column definitions:

* SMR - soil moisture regime
* SNR - soil nutrient regime
* AT - accumulated temperature
* CT - continentality
* DAMS - direct aspect method of scoring
* MD - moisture deficit
* Item - The stage of modification of the environmental dose variable values.

::: {.panel-tabset}

## Python

```{python ESCDoseVals_py}
ESCDoseVals = ESCTreeResultsresponse_dict.get("RCP2.6").get("1980_2000").get("ESCDoseVals")
ESCDoseVals
```

## R

```{r ESCDoseVals_r}
ESCDoseVals = ESCTreeResultsresponse_list$`RCP2.6`$`1980_2000`$ESCDoseVals
ESCDoseVals
```

:::

The `ESCResponseVals` data frame contains data on the response of each tree species to each environmental dose metric.
Column definitions:

* speciesCode - The Forest Research species code for the species.
* metric - The environmental dose variable (see above).
* response - The response of the tree species to the environmental dose variable. A unitless value between 0 and 1.

::: {.panel-tabset}

## Python

```{python ESCResponseVals_py}
ESCResponseVals = ESCTreeResultsresponse_dict.get("RCP2.6").get("1980_2000").get("ESCResponseVals")
ESCResponseVals.head()
```

## R

```{r ESCResponseVals_r}
ESCResponseVals = ESCTreeResultsresponse_list$`RCP2.6`$`1980_2000`$ESCResponseVals
ESCResponseVals |> head()
```

:::

The `ESCSuitMetrics` data frame contains a range of summary data relating to the suitability of each tree species based on the `ESCResponseVals` data.
Column definitions:

* speciesCode - The Forest Research species code for the species.
* speciesScientific - The scientific name of the species.
* speciesName - The common name of the species.
* maxYC - The maximum yield class of that species
* threat - Any major threats to that tree species which should be taken into account when considering planting that species.
* limFactorInclAT - The limiting factor (metric with the lowest response) including AT.
* limFactorInclATResponse - The response value for limiting factor (metric with the lowest response) including AT.
* limFactorExclAT - The limiting factor (metric with the lowest response) excluding AT.
* limFactorExclATResponse - The response value for limiting factor (metric with the lowest response) excluding AT.
* TimberSuitability - The suitability of that tree species for planting as a timber crop.
* EcologicalSuitability - The suitability of that tree species for planting.
* estimatedYC - The estimated yield class.

::: {.panel-tabset}

## Python

```{python ESCSuitMetrics_py}
ESCSuitMetrics = ESCTreeResultsresponse_dict.get("RCP2.6").get("1980_2000").get("ESCSuitMetrics")
ESCSuitMetrics.head()
```

## R

```{r ESCSuitMetrics_r}
ESCSuitMetrics = ESCTreeResultsresponse_list$`RCP2.6`$`1980_2000`$ESCSuitMetrics
ESCSuitMetrics |> head()
```

:::
